{
	"addCue": {
		"body": [
			"addCue(${1:time}, ${2:callback}, ${3:[value]})"
		],
		"description": "Schedule events to trigger every time a MediaElement (audio/video) reaches a playback cue point. Accepts a callback function, a time (in seconds) at which to trigger the callback, and an optional parameter for the callback. Time will be passed as the first parameter to the callback function, and param will be the second parameter.",
		"prefix": "addCue"
	},
	"channels": {
		"body": [
			"channels()"
		],
		"description": "Return the number of channels in a sound file. For example, Mono = 1, Stereo = 2.",
		"prefix": "channels"
	},
	"clearCues": {
		"body": [
			"clearCues()"
		],
		"description": "Remove all of the callbacks that had originally been scheduled via the addCue method.",
		"prefix": "clearCues"
	},
	"connect": {
		"body": [
			"connect(${1:[object]})"
		],
		"description": "Connects the output of a p5sound object to input of another p5.sound object. For example, you may connect a p5.SoundFile to an FFT or an Effect. If no parameter is given, it will connect to the master output. Most p5sound objects connect to the master output when they are created.",
		"prefix": "connect"
	},
	"currentTime": {
		"body": [
			"currentTime()"
		],
		"description": "Return the current position of the p5.SoundFile playhead, in seconds. Note that if you change the playbackRate while the p5.SoundFile is playing, the results may not be accurate.",
		"prefix": "currentTime"
	},
	"disconnect": {
		"body": [
			"disconnect()"
		],
		"description": "Disconnects the output of this p5sound object.",
		"prefix": "disconnect"
	},
	"duration": {
		"body": [
			"duration()"
		],
		"description": "Returns the duration of a sound file in seconds.",
		"prefix": "duration"
	},
	"frames": {
		"body": [
			"frames()"
		],
		"description": "Return the number of samples in a sound file. Equal to sampleRate * duration.",
		"prefix": "frames"
	},
	"getPeaks": {
		"body": [
			"getPeaks(${1:[length]})"
		],
		"description": "Returns an array of amplitude peaks in a p5.SoundFile that can be used to draw a static waveform. Scans through the p5.SoundFile's audio buffer to find the greatest amplitudes. Accepts one parameter, 'length', which determines size of the array. Larger arrays result in more precise waveform visualizations. Inspired by Wavesurfer.js.",
		"prefix": "getPeaks"
	},
	"isLoaded": {
		"body": [
			"isLoaded()"
		],
		"description": "Returns true if the sound file finished loading successfully.",
		"prefix": "isLoaded"
	},
	"isPaused": {
		"body": [
			"isPaused()"
		],
		"description": "Returns true if a p5.SoundFile is paused, false if not (i.e. playing or stopped).",
		"prefix": "isPaused"
	},
	"isPlaying": {
		"body": [
			"isPlaying()"
		],
		"description": "Returns true if a p5.SoundFile is playing, false if not (i.e. paused or stopped).",
		"prefix": "isPlaying"
	},
	"jump": {
		"body": [
			"jump(${1:cueTime}, ${2:duration})"
		],
		"description": "Move the playhead of the song to a position, in seconds. Start and Stop time. If none are given, will reset the file to play entire duration from start to finish.",
		"prefix": "jump"
	},
	"loadSound": {
		"body": [
			"loadSound(${1:path}, ${2:[successCallback]}, ${3:[errorCallback]}, ${4:[whileLoading]})"
		],
		"description": "loadSound() returns a new p5.SoundFile from a specified path. If called during preload(), the p5.SoundFile will be ready to play in time for setup() and draw(). If called outside of preload, the p5.SoundFile will not be ready immediately, so loadSound accepts a callback as the second parameter. Using a  local server is recommended when loading external files.",
		"prefix": "loadSound"
	},
	"loop": {
		"body": [
			"loop(${1:[startTime]}, ${2:[rate]}, ${3:[amp]}, ${4:[cueLoopStart]}, ${5:[duration]})"
		],
		"description": "Loop the p5.SoundFile. Accepts optional parameters to set the playback rate, playback volume, loopStart, loopEnd.",
		"prefix": "loop"
	},
	"onended": {
		"body": [
			"onended(${1:callback})"
		],
		"description": "Schedule an event to be called when the soundfile reaches the end of a buffer. If the soundfile is playing through once, this will be called when it ends. If it is looping, it will be called when stop is called.",
		"prefix": "onended"
	},
	"pan": {
		"body": [
			"pan(${1:[panValue]}, ${2:timeFromNow})"
		],
		"description": "Set the stereo panning of a p5.sound object to a floating point number between -1.0 (left) and 1.0 (right). Default is 0.0 (center).",
		"prefix": "pan"
	},
	"pause": {
		"body": [
			"pause(${1:[startTime]})"
		],
		"description": "Pauses a file that is currently playing. If the file is not playing, then nothing will happen. After pausing, .play() will resume from the paused position. If p5.SoundFile had been set to loop before it was paused, it will continue to loop after it is unpaused with .play().",
		"prefix": "pause"
	},
	"play": {
		"body": [
			"play(${1:[startTime]}, ${2:[rate]}, ${3:[amp]}, ${4:[cueStart]}, ${5:[duration]})"
		],
		"description": "Play the p5.SoundFile",
		"prefix": "play"
	},
	"playMode": {
		"body": [
			"playMode(${1:str})"
		],
		"description": "p5.SoundFile has two play modes: restart and sustain. Play Mode determines what happens to a p5.SoundFile if it is triggered while in the middle of playback. In sustain mode, playback will continue simultaneous to the new playback. In restart mode, play() will stop playback and start over. Sustain is the default mode.",
		"prefix": "playMode"
	},
	"processPeaks": {
		"body": [
			"processPeaks(${1:callback}, ${2:[initThreshold]}, ${3:[minThreshold]}, ${4:[minPeaks]})"
		],
		"description": "processPeaks returns an array of timestamps where it thinks there is a beat. This is an asynchronous function that processes the soundfile in an offline audio context, and sends the results to your callback function. The process involves running the soundfile through a lowpass filter, and finding all of the peaks above the initial threshold. If the total number of peaks are below the minimum number of peaks, it decreases the threshold and re-runs the analysis until either minPeaks or minThreshold are reached.",
		"prefix": "processPeaks"
	},
	"rate": {
		"body": [
			"rate(${1:[playbackRate]})"
		],
		"description": "Set the playback rate of a sound file. Will change the speed and the pitch. Values less than zero will reverse the audio buffer.",
		"prefix": "rate"
	},
	"removeCue": {
		"body": [
			"removeCue(${1:id})"
		],
		"description": "Remove a callback based on its ID. The ID is returned by the addCue method.",
		"prefix": "removeCue"
	},
	"reverseBuffer": {
		"body": [
			"reverseBuffer()"
		],
		"description": "Reverses the p5.SoundFile's buffer source. Playback must be handled separately (see example).",
		"prefix": "reverseBuffer"
	},
	"sampleRate": {
		"body": [
			"sampleRate()"
		],
		"description": "Return the sample rate of the sound file.",
		"prefix": "sampleRate"
	},
	"setPath": {
		"body": [
			"setPath(${1:path}, ${2:callback})"
		],
		"description": "Reset the source for this SoundFile to a new path (URL).",
		"prefix": "setPath"
	},
	"setVolume": {
		"body": [
			"setVolume(${1:volume}, ${2:[rampTime]}, ${3:[timeFromNow]})"
		],
		"description": "Multiply the output volume (amplitude) of a sound file between 0.0 (silence) and 1.0 (full volume). 1.0 is the maximum amplitude of a digital sound, so multiplying by greater than 1.0 may cause digital distortion. To fade, provide a rampTime parameter. For more complex fades, see the Env class. Alternately, you can pass in a signal source such as an oscillator to modulate the amplitude with an audio signal.",
		"prefix": "setVolume"
	},
	"stop": {
		"body": [
			"stop(${1:[startTime]})"
		],
		"description": "Stop soundfile playback.",
		"prefix": "stop"
	}
}